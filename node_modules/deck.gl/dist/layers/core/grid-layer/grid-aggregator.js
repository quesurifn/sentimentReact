'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pointToDensityGridData = pointToDensityGridData;
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
var R_EARTH = 6378000;

/**
 * Calculate density grid from an array of points
 * @param {array} points
 * @param {number} cellSize - cell size in meters
 * @param {function} getPosition - position accessor
 * @returns {object} - grid data, cell dimension
 */
function pointToDensityGridData(points, cellSize, getPosition) {
  var _pointsToGridHashing2 = _pointsToGridHashing(points, cellSize, getPosition),
      gridHash = _pointsToGridHashing2.gridHash,
      gridOffset = _pointsToGridHashing2.gridOffset;

  var layerData = _getGridLayerDataFromGridHash(gridHash, gridOffset);

  return {
    gridOffset: gridOffset,
    layerData: layerData
  };
}

/**
 * Project points into each cell, return a hash table of cells
 * @param {array} points
 * @param {number} cellSize - unit size in meters
 * @param {function} getPosition - position accessor
 * @returns {object} - grid hash and cell dimension
 */
function _pointsToGridHashing(points, cellSize, getPosition) {

  // find the geometric center of sample points
  var allLat = points.map(function (p) {
    return getPosition(p)[1];
  }).filter(Number.isFinite);

  var latMin = Math.min.apply(null, allLat);
  var latMax = Math.max.apply(null, allLat);
  var centerLat = (latMin + latMax) / 2;

  var gridOffset = _calculateGridLatLonOffset(cellSize, centerLat);

  if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {
    return { gridHash: {}, gridOffset: gridOffset };
  }
  // calculate count per cell
  var gridHash = points.reduce(function (accu, pt) {
    var lat = getPosition(pt)[1];
    var lng = getPosition(pt)[0];

    if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
      return accu;
    }

    var latIdx = Math.floor((lat + 90) / gridOffset.yOffset);
    var lonIdx = Math.floor((lng + 180) / gridOffset.xOffset);
    var key = latIdx + '-' + lonIdx;

    accu[key] = accu[key] || { count: 0, points: [] };
    accu[key].count += 1;
    accu[key].points.push(pt);

    return accu;
  }, {});

  return { gridHash: gridHash, gridOffset: gridOffset };
}

function _getGridLayerDataFromGridHash(gridHash, gridOffset) {
  return Object.keys(gridHash).reduce(function (accu, key, i) {
    var idxs = key.split('-');
    var latIdx = parseInt(idxs[0], 10);
    var lonIdx = parseInt(idxs[1], 10);

    accu.push(Object.assign({
      index: i,
      position: [-180 + gridOffset.xOffset * lonIdx, -90 + gridOffset.yOffset * latIdx]
    }, gridHash[key]));

    return accu;
  }, []);
}

/**
 * calculate grid layer cell size in lat lon based on world unit size
 * and current latitude
 * @param {number} cellSize
 * @param {number} latitude
 * @returns {object} - lat delta and lon delta
 */
function _calculateGridLatLonOffset(cellSize, latitude) {
  var yOffset = _calculateLatOffset(cellSize);
  var xOffset = _calculateLonOffset(latitude, cellSize);
  return { yOffset: yOffset, xOffset: xOffset };
}

/**
 * with a given x-km change, calculate the increment of latitude
 * based on stackoverflow http://stackoverflow.com/questions/7477003
 * @param {number} dy - change in km
 * @return {number} - increment in latitude
 */
function _calculateLatOffset(dy) {
  return dy / R_EARTH * (180 / Math.PI);
}

/**
 * with a given x-km change, and current latitude
 * calculate the increment of longitude
 * based on stackoverflow http://stackoverflow.com/questions/7477003
 * @param {number} lat - latitude of current location (based on city)
 * @param {number} dx - change in km
 * @return {number} - increment in longitude
 */
function _calculateLonOffset(lat, dx) {
  return dx / R_EARTH * (180 / Math.PI) / Math.cos(lat * Math.PI / 180);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9ncmlkLWxheWVyL2dyaWQtYWdncmVnYXRvci5qcyJdLCJuYW1lcyI6WyJwb2ludFRvRGVuc2l0eUdyaWREYXRhIiwiUl9FQVJUSCIsInBvaW50cyIsImNlbGxTaXplIiwiZ2V0UG9zaXRpb24iLCJfcG9pbnRzVG9HcmlkSGFzaGluZyIsImdyaWRIYXNoIiwiZ3JpZE9mZnNldCIsImxheWVyRGF0YSIsIl9nZXRHcmlkTGF5ZXJEYXRhRnJvbUdyaWRIYXNoIiwiYWxsTGF0IiwibWFwIiwicCIsImZpbHRlciIsIk51bWJlciIsImlzRmluaXRlIiwibGF0TWluIiwiTWF0aCIsIm1pbiIsImFwcGx5IiwibGF0TWF4IiwibWF4IiwiY2VudGVyTGF0IiwiX2NhbGN1bGF0ZUdyaWRMYXRMb25PZmZzZXQiLCJ4T2Zmc2V0IiwieU9mZnNldCIsInJlZHVjZSIsImFjY3UiLCJwdCIsImxhdCIsImxuZyIsImxhdElkeCIsImZsb29yIiwibG9uSWR4Iiwia2V5IiwiY291bnQiLCJwdXNoIiwiT2JqZWN0Iiwia2V5cyIsImkiLCJpZHhzIiwic3BsaXQiLCJwYXJzZUludCIsImFzc2lnbiIsImluZGV4IiwicG9zaXRpb24iLCJsYXRpdHVkZSIsIl9jYWxjdWxhdGVMYXRPZmZzZXQiLCJfY2FsY3VsYXRlTG9uT2Zmc2V0IiwiZHkiLCJQSSIsImR4IiwiY29zIl0sIm1hcHBpbmdzIjoiOzs7OztRQTRCZ0JBLHNCLEdBQUFBLHNCO0FBNUJoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQU1DLFVBQVUsT0FBaEI7O0FBRUE7Ozs7Ozs7QUFPTyxTQUFTRCxzQkFBVCxDQUFnQ0UsTUFBaEMsRUFBd0NDLFFBQXhDLEVBQWtEQyxXQUFsRCxFQUErRDtBQUFBLDhCQUVyQ0MscUJBQXFCSCxNQUFyQixFQUE2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TSxNQUFQLENBQWM7QUFDdEJDLGFBQU9MLENBRGU7QUFFdEJNLGdCQUFVLENBQ1IsQ0FBQyxHQUFELEdBQU90QyxXQUFXaUIsT0FBWCxHQUFxQlMsTUFEcEIsRUFFUixDQUFDLEVBQUQsR0FBTTFCLFdBQVdrQixPQUFYLEdBQXFCTSxNQUZuQjtBQUZZLEtBQWQsRUFNUHpCLFNBQVM0QixHQUFULENBTk8sQ0FBVjs7QUFRQSxXQUFPUCxJQUFQO0FBQ0QsR0FkTSxFQWNKLEVBZEksQ0FBUDtBQWVEOztBQUVEOzs7Ozs7O0FBT0EsU0FBU0osMEJBQVQsQ0FBb0NwQixRQUFwQyxFQUE4QzJDLFFBQTlDLEVBQXdEO0FBQ3RELE1BQU1yQixVQUFVc0Isb0JBQW9CNUMsUUFBcEIsQ0FBaEI7QUFDQSxNQUFNcUIsVUFBVXdCLG9CQUFvQkYsUUFBcEIsRUFBOEIzQyxRQUE5QixDQUFoQjtBQUNBLFNBQU8sRUFBQ3NCLGdCQUFELEVBQVVELGdCQUFWLEVBQVA7QUFDRDs7QUFFRDs7Ozs7O0FBTUEsU0FBU3VCLG1CQUFULENBQTZCRSxFQUE3QixFQUFpQztBQUMvQixTQUFRQSxLQUFLaEQsT0FBTixJQUFrQixNQUFNZ0IsS0FBS2lDLEVBQTdCLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRQSxTQUFTRixtQkFBVCxDQUE2Qm5CLEdBQTdCLEVBQWtDc0IsRUFBbEMsRUFBc0M7QUFDcEMsU0FBUUEsS0FBS2xELE9BQU4sSUFBa0IsTUFBTWdCLEtBQUtpQyxFQUE3QixJQUFtQ2pDLEtBQUttQyxHQUFMLENBQVN2QixNQUFNWixLQUFLaUMsRUFBWCxHQUFnQixHQUF6QixDQUExQztBQUNEIiwiZmlsZSI6ImdyaWQtYWdncmVnYXRvci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuY29uc3QgUl9FQVJUSCA9IDYzNzgwMDA7XG5cbi8qKlxuICogQ2FsY3VsYXRlIGRlbnNpdHkgZ3JpZCBmcm9tIGFuIGFycmF5IG9mIHBvaW50c1xuICogQHBhcmFtIHthcnJheX0gcG9pbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gY2VsbFNpemUgLSBjZWxsIHNpemUgaW4gbWV0ZXJzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBnZXRQb3NpdGlvbiAtIHBvc2l0aW9uIGFjY2Vzc29yXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAtIGdyaWQgZGF0YSwgY2VsbCBkaW1lbnNpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvaW50VG9EZW5zaXR5R3JpZERhdGEocG9pbnRzLCBjZWxsU2l6ZSwgZ2V0UG9zaXRpb24pIHtcblxuICBjb25zdCB7Z3JpZEhhc2gsIGdyaWRPZmZzZXR9ID0gX3BvaW50c1RvR3JpZEhhc2hpbmcocG9pbnRzLCBjZWxsU2l6ZSwgZ2V0UG9zaXRpb24pO1xuICBjb25zdCBsYXllckRhdGEgPSBfZ2V0R3JpZExheWVyRGF0YUZyb21HcmlkSGFzaChncmlkSGFzaCwgZ3JpZE9mZnNldCk7XG5cbiAgcmV0dXJuIHtcbiAgICBncmlkT2Zmc2V0LFxuICAgIGxheWVyRGF0YVxuICB9O1xufVxuXG4vKipcbiAqIFByb2plY3QgcG9pbnRzIGludG8gZWFjaCBjZWxsLCByZXR1cm4gYSBoYXNoIHRhYmxlIG9mIGNlbGxzXG4gKiBAcGFyYW0ge2FycmF5fSBwb2ludHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBjZWxsU2l6ZSAtIHVuaXQgc2l6ZSBpbiBtZXRlcnNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGdldFBvc2l0aW9uIC0gcG9zaXRpb24gYWNjZXNzb3JcbiAqIEByZXR1cm5zIHtvYmplY3R9IC0gZ3JpZCBoYXNoIGFuZCBjZWxsIGRpbWVuc2lvblxuICovXG5mdW5jdGlvbiBfcG9pbnRzVG9HcmlkSGFzaGluZyhwb2ludHMsIGNlbGxTaXplLCBnZXRQb3NpdGlvbikge1xuXG4gIC8vIGZpbmQgdGhlIGdlb21ldHJpYyBjZW50ZXIgb2Ygc2FtcGxlIHBvaW50c1xuICBjb25zdCBhbGxMYXQgPSBwb2ludHNcbiAgICAubWFwKHAgPT4gZ2V0UG9zaXRpb24ocClbMV0pXG4gICAgLmZpbHRlcihOdW1iZXIuaXNGaW5pdGUpO1xuXG4gIGNvbnN0IGxhdE1pbiA9IE1hdGgubWluLmFwcGx5KG51bGwsIGFsbExhdCk7XG4gIGNvbnN0IGxhdE1heCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIGFsbExhdCk7XG4gIGNvbnN0IGNlbnRlckxhdCA9IChsYXRNaW4gKyBsYXRNYXgpIC8gMjtcblxuICBjb25zdCBncmlkT2Zmc2V0ID0gX2NhbGN1bGF0ZUdyaWRMYXRMb25PZmZzZXQoY2VsbFNpemUsIGNlbnRlckxhdCk7XG5cbiAgaWYgKGdyaWRPZmZzZXQueE9mZnNldCA8PSAwIHx8IGdyaWRPZmZzZXQueU9mZnNldCA8PSAwKSB7XG4gICAgcmV0dXJuIHtncmlkSGFzaDoge30sIGdyaWRPZmZzZXR9O1xuICB9XG4gIC8vIGNhbGN1bGF0ZSBjb3VudCBwZXIgY2VsbFxuICBjb25zdCBncmlkSGFzaCA9IHBvaW50cy5yZWR1Y2UoKGFjY3UsIHB0KSA9PiB7XG4gICAgY29uc3QgbGF0ID0gZ2V0UG9zaXRpb24ocHQpWzFdO1xuICAgIGNvbnN0IGxuZyA9IGdldFBvc2l0aW9uKHB0KVswXTtcblxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGxhdCkgfHwgIU51bWJlci5pc0Zpbml0ZShsbmcpKSB7XG4gICAgICByZXR1cm4gYWNjdTtcbiAgICB9XG5cbiAgICBjb25zdCBsYXRJZHggPSBNYXRoLmZsb29yKChsYXQgKyA5MCkgLyBncmlkT2Zmc2V0LnlPZmZzZXQpO1xuICAgIGNvbnN0IGxvbklkeCA9IE1hdGguZmxvb3IoKGxuZyArIDE4MCkgLyBncmlkT2Zmc2V0LnhPZmZzZXQpO1xuICAgIGNvbnN0IGtleSA9IGAke2xhdElkeH0tJHtsb25JZHh9YDtcblxuICAgIGFjY3Vba2V5XSA9IGFjY3Vba2V5XSB8fCB7Y291bnQ6IDAsIHBvaW50czogW119O1xuICAgIGFjY3Vba2V5XS5jb3VudCArPSAxO1xuICAgIGFjY3Vba2V5XS5wb2ludHMucHVzaChwdCk7XG5cbiAgICByZXR1cm4gYWNjdTtcbiAgfSwge30pO1xuXG4gIHJldHVybiB7Z3JpZEhhc2gsIGdyaWRPZmZzZXR9O1xufVxuXG5mdW5jdGlvbiBfZ2V0R3JpZExheWVyRGF0YUZyb21HcmlkSGFzaChncmlkSGFzaCwgZ3JpZE9mZnNldCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoZ3JpZEhhc2gpLnJlZHVjZSgoYWNjdSwga2V5LCBpKSA9PiB7XG4gICAgY29uc3QgaWR4cyA9IGtleS5zcGxpdCgnLScpO1xuICAgIGNvbnN0IGxhdElkeCA9IHBhcnNlSW50KGlkeHNbMF0sIDEwKTtcbiAgICBjb25zdCBsb25JZHggPSBwYXJzZUludChpZHhzWzFdLCAxMCk7XG5cbiAgICBhY2N1LnB1c2goT2JqZWN0LmFzc2lnbih7XG4gICAgICBpbmRleDogaSxcbiAgICAgIHBvc2l0aW9uOiBbXG4gICAgICAgIC0xODAgKyBncmlkT2Zmc2V0LnhPZmZzZXQgKiBsb25JZHgsXG4gICAgICAgIC05MCArIGdyaWRPZmZzZXQueU9mZnNldCAqIGxhdElkeFxuICAgICAgXVxuICAgIH0sIGdyaWRIYXNoW2tleV0pKTtcblxuICAgIHJldHVybiBhY2N1O1xuICB9LCBbXSk7XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIGdyaWQgbGF5ZXIgY2VsbCBzaXplIGluIGxhdCBsb24gYmFzZWQgb24gd29ybGQgdW5pdCBzaXplXG4gKiBhbmQgY3VycmVudCBsYXRpdHVkZVxuICogQHBhcmFtIHtudW1iZXJ9IGNlbGxTaXplXG4gKiBAcGFyYW0ge251bWJlcn0gbGF0aXR1ZGVcbiAqIEByZXR1cm5zIHtvYmplY3R9IC0gbGF0IGRlbHRhIGFuZCBsb24gZGVsdGFcbiAqL1xuZnVuY3Rpb24gX2NhbGN1bGF0ZUdyaWRMYXRMb25PZmZzZXQoY2VsbFNpemUsIGxhdGl0dWRlKSB7XG4gIGNvbnN0IHlPZmZzZXQgPSBfY2FsY3VsYXRlTGF0T2Zmc2V0KGNlbGxTaXplKTtcbiAgY29uc3QgeE9mZnNldCA9IF9jYWxjdWxhdGVMb25PZmZzZXQobGF0aXR1ZGUsIGNlbGxTaXplKTtcbiAgcmV0dXJuIHt5T2Zmc2V0LCB4T2Zmc2V0fTtcbn1cblxuLyoqXG4gKiB3aXRoIGEgZ2l2ZW4geC1rbSBjaGFuZ2UsIGNhbGN1bGF0ZSB0aGUgaW5jcmVtZW50IG9mIGxhdGl0dWRlXG4gKiBiYXNlZCBvbiBzdGFja292ZXJmbG93IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzQ3NzAwM1xuICogQHBhcmFtIHtudW1iZXJ9IGR5IC0gY2hhbmdlIGluIGttXG4gKiBAcmV0dXJuIHtudW1iZXJ9IC0gaW5jcmVtZW50IGluIGxhdGl0dWRlXG4gKi9cbmZ1bmN0aW9uIF9jYWxjdWxhdGVMYXRPZmZzZXQoZHkpIHtcbiAgcmV0dXJuIChkeSAvIFJfRUFSVEgpICogKDE4MCAvIE1hdGguUEkpO1xufVxuXG4vKipcbiAqIHdpdGggYSBnaXZlbiB4LWttIGNoYW5nZSwgYW5kIGN1cnJlbnQgbGF0aXR1ZGVcbiAqIGNhbGN1bGF0ZSB0aGUgaW5jcmVtZW50IG9mIGxvbmdpdHVkZVxuICogYmFzZWQgb24gc3RhY2tvdmVyZmxvdyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc0NzcwMDNcbiAqIEBwYXJhbSB7bnVtYmVyfSBsYXQgLSBsYXRpdHVkZSBvZiBjdXJyZW50IGxvY2F0aW9uIChiYXNlZCBvbiBjaXR5KVxuICogQHBhcmFtIHtudW1iZXJ9IGR4IC0gY2hhbmdlIGluIGttXG4gKiBAcmV0dXJuIHtudW1iZXJ9IC0gaW5jcmVtZW50IGluIGxvbmdpdHVkZVxuICovXG5mdW5jdGlvbiBfY2FsY3VsYXRlTG9uT2Zmc2V0KGxhdCwgZHgpIHtcbiAgcmV0dXJuIChkeCAvIFJfRUFSVEgpICogKDE4MCAvIE1hdGguUEkpIC8gTWF0aC5jb3MobGF0ICogTWF0aC5QSSAvIDE4MCk7XG59XG4iXX0=