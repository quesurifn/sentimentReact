'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.drawLayers = drawLayers;
exports.queryLayers = queryLayers;
exports.pickLayers = pickLayers;

var _luma = require('luma.gl');

var _utils = require('./utils');

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window */
var EMPTY_PIXEL = new Uint8Array(4);
var renderCount = 0;

function drawLayers(_ref) {
  var layers = _ref.layers,
      pass = _ref.pass;

  // render layers in normal colors
  var visibleCount = 0;
  var compositeCount = 0;
  // render layers in normal colors
  layers.forEach(function (layer, layerIndex) {
    if (layer.isComposite) {
      compositeCount++;
    } else if (layer.props.visible) {

      layer.drawLayer({
        moduleParameters: Object.assign({}, layer.props, {
          viewport: layer.context.viewport
        }),
        uniforms: Object.assign({ renderPickingBuffer: 0, pickingEnabled: 0 }, layer.context.uniforms, { layerIndex: layerIndex }),
        parameters: layer.props.parameters || {}
      });
      visibleCount++;
    }
  });
  var totalCount = layers.length;
  var primitiveCount = totalCount - compositeCount;
  var hiddenCount = primitiveCount - visibleCount;

  var message = '#' + renderCount++ + ': Rendering ' + visibleCount + ' of ' + totalCount + ' layers ' + pass + ' (' + hiddenCount + ' hidden, ' + compositeCount + ' composite)';

  _utils.log.log(2, message);
}

// Pick all objects within the given bounding box
function queryLayers(gl, _ref2) {
  var layers = _ref2.layers,
      pickingFBO = _ref2.pickingFBO,
      x = _ref2.x,
      y = _ref2.y,
      width = _ref2.width,
      height = _ref2.height,
      viewport = _ref2.viewport,
      mode = _ref2.mode;


  // Convert from canvas top-left to WebGL bottom-left coordinates
  // And compensate for pixelRatio
  var pixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
  var deviceLeft = Math.round(x * pixelRatio);
  var deviceBottom = Math.round(gl.canvas.height - y * pixelRatio);
  var deviceRight = Math.round((x + width) * pixelRatio);
  var deviceTop = Math.round(gl.canvas.height - (y + height) * pixelRatio);

  var pickInfos = getUniquesFromPickingBuffer(gl, {
    layers: layers,
    pickingFBO: pickingFBO,
    deviceRect: {
      x: deviceLeft,
      y: deviceTop,
      width: deviceRight - deviceLeft,
      height: deviceBottom - deviceTop
    }
  });

  // Only return unique infos, identified by info.object
  var uniqueInfos = new Map();

  pickInfos.forEach(function (pickInfo) {
    var info = createInfo([pickInfo.x / pixelRatio, pickInfo.y / pixelRatio], viewport);
    info.devicePixel = [pickInfo.x, pickInfo.y];
    info.pixelRatio = pixelRatio;
    info.color = pickInfo.pickedColor;
    info.index = pickInfo.pickedObjectIndex;
    info.picked = true;

    info = getLayerPickingInfo({ layer: pickInfo.pickedLayer, info: info, mode: mode });
    if (!uniqueInfos.has(info.object)) {
      uniqueInfos.set(info.object, info);
    }
  });

  return Array.from(uniqueInfos.values());
}

/* eslint-disable max-depth, max-statements */
// Pick the closest object at the given (x,y) coordinate
function pickLayers(gl, _ref3) {
  var layers = _ref3.layers,
      pickingFBO = _ref3.pickingFBO,
      x = _ref3.x,
      y = _ref3.y,
      radius = _ref3.radius,
      viewport = _ref3.viewport,
      mode = _ref3.mode,
      lastPickedInfo = _ref3.lastPickedInfo;


  // Convert from canvas top-left to WebGL bottom-left coordinates
  // And compensate for pixelRatio
  var pixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
  var deviceX = Math.round(x * pixelRatio);
  var deviceY = Math.round(gl.canvas.height - y * pixelRatio);
  var deviceRadius = Math.round(radius * pixelRatio);

  var _getClosestFromPickin = getClosestFromPickingBuffer(gl, {
    layers: layers,
    pickingFBO: pickingFBO,
    deviceX: deviceX,
    deviceY: deviceY,
    deviceRadius: deviceRadius
  }),
      pickedColor = _getClosestFromPickin.pickedColor,
      pickedLayer = _getClosestFromPickin.pickedLayer,
      pickedObjectIndex = _getClosestFromPickin.pickedObjectIndex;

  var affectedLayers = pickedLayer ? [pickedLayer] : [];

  if (mode === 'hover') {
    // only invoke onHover events if picked object has changed
    var lastPickedObjectIndex = lastPickedInfo.index;
    var lastPickedLayerId = lastPickedInfo.layerId;
    var pickedLayerId = pickedLayer && pickedLayer.props.id;

    // proceed only if picked object changed
    if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedObjectIndex) {
      if (pickedLayerId !== lastPickedLayerId) {
        // We cannot store a ref to lastPickedLayer in the context because
        // the state of an outdated layer is no longer valid
        // and the props may have changed
        var lastPickedLayer = layers.find(function (layer) {
          return layer.props.id === lastPickedLayerId;
        });
        if (lastPickedLayer) {
          // Let leave event fire before enter event
          affectedLayers.unshift(lastPickedLayer);
        }
      }

      // Update layer manager context
      lastPickedInfo.layerId = pickedLayerId;
      lastPickedInfo.index = pickedObjectIndex;
    }
  }

  var baseInfo = createInfo([x, y], viewport);
  baseInfo.devicePixel = [deviceX, deviceY];
  baseInfo.pixelRatio = pixelRatio;

  // Use a Map to store all picking infos.
  // The following two forEach loops are the result of
  // https://github.com/uber/deck.gl/issues/443
  // Please be very careful when changing this pattern
  var infos = new Map();
  var unhandledPickInfos = [];

  affectedLayers.forEach(function (layer) {
    var info = Object.assign({}, baseInfo);

    if (layer === pickedLayer) {
      info.color = pickedColor;
      info.index = pickedObjectIndex;
      info.picked = true;
    }

    info = getLayerPickingInfo({ layer: layer, info: info, mode: mode });

    // This guarantees that there will be only one copy of info for
    // one composite layer
    if (info) {
      infos.set(info.layer.id, info);
    }
  });

  infos.forEach(function (info) {
    var handled = false;
    // Per-layer event handlers (e.g. onClick, onHover) are provided by the
    // user and out of deck.gl's control. It's very much possible that
    // the user calls React lifecycle methods in these function, such as
    // ReactComponent.setState(). React lifecycle methods sometimes induce
    // a re-render and re-generation of props of deck.gl and its layers,
    // which invalidates all layers currently passed to this very function.

    // Therefore, per-layer event handlers must be invoked at the end
    // of this function. NO operation that relies on the states of current
    // layers should be called after this code.
    switch (mode) {
      case 'click':
        handled = info.layer.props.onClick(info);break;
      case 'hover':
        handled = info.layer.props.onHover(info);break;
      case 'query':
        break;
      default:
        throw new Error('unknown pick type');
    }

    if (!handled) {
      unhandledPickInfos.push(info);
    }
  });

  return unhandledPickInfos;
}

/**
 * Pick at a specified pixel with a tolerance radius
 * Returns the closest object to the pixel in shape `{pickedColor, pickedLayer, pickedObjectIndex}`
 */
function getClosestFromPickingBuffer(gl, _ref4) {
  var layers = _ref4.layers,
      pickingFBO = _ref4.pickingFBO,
      deviceX = _ref4.deviceX,
      deviceY = _ref4.deviceY,
      deviceRadius = _ref4.deviceRadius;

  // Create a box of size `radius * 2 + 1` centered at [deviceX, deviceY]
  var x = Math.max(0, deviceX - deviceRadius);
  var y = Math.max(0, deviceY - deviceRadius);
  var width = Math.min(pickingFBO.width, deviceX + deviceRadius) - x + 1;
  var height = Math.min(pickingFBO.height, deviceY + deviceRadius) - y + 1;

  var pickedColors = getPickedColors(gl, { layers: layers, pickingFBO: pickingFBO, deviceRect: { x: x, y: y, width: width, height: height } });

  // Traverse all pixels in picking results and find the one closest to the supplied
  // [deviceX, deviceY]
  var minSquareDistanceToCenter = deviceRadius * deviceRadius;
  var closestResultToCenter = {
    pickedColor: EMPTY_PIXEL,
    pickedLayer: null,
    pickedObjectIndex: -1
  };
  var i = 0;

  for (var row = 0; row < height; row++) {
    for (var col = 0; col < width; col++) {
      // Decode picked layer from color
      var pickedLayerIndex = pickedColors[i + 3] - 1;

      if (pickedLayerIndex >= 0) {
        var dx = col + x - deviceX;
        var dy = row + y - deviceY;
        var d2 = dx * dx + dy * dy;

        if (d2 <= minSquareDistanceToCenter) {
          minSquareDistanceToCenter = d2;

          // Decode picked object index from color
          var pickedColor = pickedColors.slice(i, i + 4);
          var pickedLayer = layers[pickedLayerIndex];
          var pickedObjectIndex = pickedLayer.decodePickingColor(pickedColor);
          closestResultToCenter = { pickedColor: pickedColor, pickedLayer: pickedLayer, pickedObjectIndex: pickedObjectIndex };
        }
      }
      i += 4;
    }
  }

  return closestResultToCenter;
}
/* eslint-enable max-depth, max-statements */

/**
 * Query within a specified rectangle
 * Returns array of unique objects in shape `{x, y, pickedColor, pickedLayer, pickedObjectIndex}`
 */
function getUniquesFromPickingBuffer(gl, _ref5) {
  var layers = _ref5.layers,
      pickingFBO = _ref5.pickingFBO,
      _ref5$deviceRect = _ref5.deviceRect,
      x = _ref5$deviceRect.x,
      y = _ref5$deviceRect.y,
      width = _ref5$deviceRect.width,
      height = _ref5$deviceRect.height;

  var pickedColors = getPickedColors(gl, { layers: layers, pickingFBO: pickingFBO, deviceRect: { x: x, y: y, width: width, height: height } });
  var uniqueColors = new Map();

  // Traverse all pixels in picking results and get unique colors
  for (var i = 0; i < pickedColors.length; i += 4) {
    // Decode picked layer from color
    var pickedLayerIndex = pickedColors[i + 3] - 1;

    if (pickedLayerIndex >= 0) {
      var pickedColor = pickedColors.slice(i, i + 4);
      var colorKey = pickedColor.join(',');
      if (!uniqueColors.has(colorKey)) {
        var pickedLayer = layers[pickedLayerIndex];
        uniqueColors.set(colorKey, {
          pickedColor: pickedColor,
          pickedLayer: pickedLayer,
          pickedObjectIndex: pickedLayer.decodePickingColor(pickedColor)
        });
      }
    }
  }

  return Array.from(uniqueColors.values());
}

// Returns an Uint8ClampedArray of picked pixels
function getPickedColors(gl, _ref6) {
  var layers = _ref6.layers,
      pickingFBO = _ref6.pickingFBO,
      _ref6$deviceRect = _ref6.deviceRect,
      x = _ref6$deviceRect.x,
      y = _ref6$deviceRect.y,
      width = _ref6$deviceRect.width,
      height = _ref6$deviceRect.height;

  // Make sure we clear scissor test and fbo bindings in case of exceptions
  // We are only interested in one pixel, no need to render anything else
  // Note that the callback here is called synchronously.
  // Set blend mode for picking
  // always overwrite existing pixel with [r,g,b,layerIndex]
  return (0, _luma.withParameters)(gl, {
    framebuffer: pickingFBO,
    scissorTest: true,
    scissor: [x, y, width, height],
    blend: true,
    blendFunc: [gl.ONE, gl.ZERO, gl.CONSTANT_ALPHA, gl.ZERO],
    blendEquation: gl.FUNC_ADD
    // TODO - Set clear color
  }, function () {

    // Clear the frame buffer
    gl.clear(_luma.GL.COLOR_BUFFER_BIT | _luma.GL.DEPTH_BUFFER_BIT);

    // Render all pickable layers in picking colors
    layers.forEach(function (layer, layerIndex) {
      if (!layer.isComposite && layer.props.visible && layer.props.pickable) {

        // Encode layerIndex with alpha
        (0, _luma.setParameters)(gl, { blendColor: [0, 0, 0, (layerIndex + 1) / 255] });
        layer.drawLayer({
          moduleParameters: Object.assign({}, layer.props, {
            viewport: layer.context.viewport
          }),
          uniforms: Object.assign({ renderPickingBuffer: 1, pickingEnabled: 1 }, layer.context.uniforms, { layerIndex: layerIndex }),
          parameters: layer.props.parameters || {}
        });
      }
    });

    // Read color in the central pixel, to be mapped with picking colors
    var pickedColors = new Uint8Array(width * height * 4);
    gl.readPixels(x, y, width, height, _luma.GL.RGBA, _luma.GL.UNSIGNED_BYTE, pickedColors);

    return pickedColors;
  });
}

function createInfo(pixel, viewport) {
  // Assign a number of potentially useful props to the "info" object
  return {
    color: EMPTY_PIXEL,
    layer: null,
    index: -1,
    picked: false,
    x: pixel[0],
    y: pixel[1],
    pixel: pixel,
    lngLat: viewport.unproject(pixel)
  };
}

// Walk up the layer composite chain to populate the info object
function getLayerPickingInfo(_ref7) {
  var layer = _ref7.layer,
      info = _ref7.info,
      mode = _ref7.mode;

  while (layer && info) {
    // For a composite layer, sourceLayer will point to the sublayer
    // where the event originates from.
    // It provides additional context for the composite layer's
    // getPickingInfo() method to populate the info object
    var sourceLayer = info.layer || layer;
    info.layer = layer;
    // layer.pickLayer() function requires a non-null ```layer.state```
    // object to funtion properly. So the layer refereced here
    // must be the "current" layer, not an "out-dated" / "invalidated" layer
    info = layer.pickLayer({ info: info, mode: mode, sourceLayer: sourceLayer });
    layer = layer.parentLayer;
  }
  return info;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvZHJhdy1hbmQtcGljay5qcyJdLCJuYW1lcyI6WyJkcmF3TGF5ZXJzIiwicXVlcnlMYXllcnMiLCJwaWNrTGF5ZXJzIiwiRU1QVFlfUElYRUwiLCJVaW50OEFycmF5IiwicmVuZGVyQ291bnQiLCJsYXllcnMiLCJwYXNzIiwidmlzaWJsZUNvdW50IiwiY29tcG9zaXRlQ291bnQiLCJmb3JFYWNoIiwibGF5ZXIiLCJsYXllckluZGV4IiwiaXNDb21wb3NpdGUiLCJwcm9wcyIsInZpc2libGUiLCJkcmF3TGF5ZXIiLCJtb2R1bGVQYXJhbWV0ZXJzIiwiT2JqZWN0IiwiYXNzaWduIiwidmlld3BvcnQiLCJjb250ZXh0IiwidW5pZm9ybXMiLCJyZW5kZXJQaWNraW5nQnVmZmVyIiwicGlja2luZ0VuYWJsZWQiLCJwYXJhbWV0ZXJzIiwidG90YWxDb3VudCIsImxlbmd0aCIsInByaW1pdGl2ZUNvdW50IiwiaGlkZGVuQ291bnQiLCJtZXNzYWdlIiwibG9nIiwiZ2wiLCJwaWNraW5nRkJPIiwieCIsInkiLCJ3aWR0aCIsImhlaWdodCIsIm1vZGUiLCJwaXhlbFJhdGlvIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsImRldmljZUxlZnQiLCJNYXRoIiwicm91bmQiLCJkZXZpY2VCb3R0b20iLCJjYW52YXMiLCJkZXZpY2VSaWdodCIsImRldmljZVRvcCIsInBpY2tJbmZvcyIsImdldFVuaXF1ZXNGcm9tUGlja2luZ0J1ZmZlciIsImRldmljZVJlY3QiLCJ1bmlxdWVJbmZvcyIsIk1hcCIsImluZm8iLCJjcmVhdGVJbmZvIiwicGlja0luZm8iLCJkZXZpY2VQaXhlbCIsImNvbG9yIiwicGlja2VkQ29sb3IiLCJpbmRleCIsInBpY2tlZE9iamVjdEluZGV4IiwicGlja2VkIiwiZ2V0TGF5ZXJQaWNraW5nSW5mbyIsInBpY2tlZExheWVyIiwiaGFzIiwib2JqZWN0Iiwic2V0IiwiQXJyYXkiLCJmcm9tIiwidmFsdWVzIiwicmFkaXVzIiwibGFzdFBpY2tlZEluZm8iLCJkZXZpY2VYIiwiZGV2aWNlWSIsImRldmljZVJhZGl1cyIsImdldENsb3Nlc3RGcm9tUGlja2luZ0J1ZmZlciIsImFmZmVjdGVkTGF5ZXJzIiwibGFzdFBpY2tlZE9iamVjdEluZGV4IiwibGFzdFBpY2tlZExheWVySWQiLCJsYXllcklkIiwicGlja2VkTGF5ZXJJZCIsImlkIiwibGFzdFBpY2tlZExheWVyIiwiZmluZCIsInVuc2hpZnQiLCJiYXNlSW5mbyIsImluZm9zIiwidW5oYW5kbGVkUGlja0luZm9zIiwiaGFuZGxlZCIsIm9uQ2xpY2siLCJvbkhvdmVyIiwiRXJyb3IiLCJwdXNoIiwibWF4IiwibWluIiwicGlja2VkQ29sb3JzIiwiZ2V0UGlja2VkQ29sb3JzIiwibWluU3F1YXJlRGlzdGFuY2VUb0NlbnRlciIsImNsb3Nlc3RSZXN1bHRUb0NlbnRlciIsImkiLCJyb3ciLCJjb2wiLCJwaWNrZWRMYXllckluZGV4IiwiZHgiLCJkeSIsImQyIiwic2xpY2UiLCJkZWNvZGVQaWNraW5nQ29sb3IiLCJ1bmlxdWVDb2xvcnMiLCJjb2xvcktleSIsImpvaW4iLCJmcmFtZWJ1ZmZlciIsInNjaXNzb3JUZXN0Iiwic2Npc3NvciIsImJsZW5kIiwiYmxlbmRGdW5jIiwiT05FIiwiWkVSTyIsIkNPTlNUQU5UX0FMUEhBIiwiYmxlbmRFcXVhdGlvbiIsIkZVTkNfQUREIiwiY2xlYXIiLCJDT0xPUl9CVUZGRVJfQklUIiwiREVQVEhfQlVGRkVSX0JJVCIsInBpY2thYmxlIiwiYmxlbmRDb2xvciIsInJlYWRQaXhlbHMiLCJSR0JBIiwiVU5TSUdORURfQllURSIsInBpeGVsIiwibG5nTGF0IiwidW5wcm9qZWN0Iiwic291cmNlTGF5ZXIiLCJwaWNrTGF5ZXIiLCJwYXJlbnRMYXllciJdLCJtYXBwaW5ncyI6Ijs7Ozs7UUEyQmdCQSxVLEdBQUFBLFU7UUFvQ0FDLFcsR0FBQUEsVztRQW9EQUMsVSxHQUFBQSxVOztBQTlGaEI7O0FBQ0E7O0FBdEJBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0FBTixDQU5FO0FBT0xBLGdCQVBLO0FBUUxDLFlBQVEvRyxTQUFTZ0gsU0FBVCxDQUFtQkYsS0FBbkI7QUFSSCxHQUFQO0FBVUQ7O0FBRUQ7QUFDQSxTQUFTbkUsbUJBQVQsUUFBa0Q7QUFBQSxNQUFwQnBELEtBQW9CLFNBQXBCQSxLQUFvQjtBQUFBLE1BQWIyQyxJQUFhLFNBQWJBLElBQWE7QUFBQSxNQUFQaEIsSUFBTyxTQUFQQSxJQUFPOztBQUNoRCxTQUFPM0IsU0FBUzJDLElBQWhCLEVBQXNCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTStFLGNBQWMvRSxLQUFLM0MsS0FBTCxJQUFjQSxLQUFsQztBQUNBMkMsU0FBSzNDLEtBQUwsR0FBYUEsS0FBYjtBQUNBO0FBQ0E7QUFDQTtBQUNBMkMsV0FBTzNDLE1BQU0ySCxTQUFOLENBQWdCLEVBQUNoRixVQUFELEVBQU9oQixVQUFQLEVBQWErRix3QkFBYixFQUFoQixDQUFQO0FBQ0ExSCxZQUFRQSxNQUFNNEgsV0FBZDtBQUNEO0FBQ0QsU0FBT2pGLElBQVA7QUFDRCIsImZpbGUiOiJkcmF3LWFuZC1waWNrLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbi8qIGdsb2JhbCB3aW5kb3cgKi9cbmltcG9ydCB7R0wsIHdpdGhQYXJhbWV0ZXJzLCBzZXRQYXJhbWV0ZXJzfSBmcm9tICdsdW1hLmdsJztcbmltcG9ydCB7bG9nfSBmcm9tICcuL3V0aWxzJztcblxuY29uc3QgRU1QVFlfUElYRUwgPSBuZXcgVWludDhBcnJheSg0KTtcbmxldCByZW5kZXJDb3VudCA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBkcmF3TGF5ZXJzKHtsYXllcnMsIHBhc3N9KSB7XG4gIC8vIHJlbmRlciBsYXllcnMgaW4gbm9ybWFsIGNvbG9yc1xuICBsZXQgdmlzaWJsZUNvdW50ID0gMDtcbiAgbGV0IGNvbXBvc2l0ZUNvdW50ID0gMDtcbiAgLy8gcmVuZGVyIGxheWVycyBpbiBub3JtYWwgY29sb3JzXG4gIGxheWVycy5mb3JFYWNoKChsYXllciwgbGF5ZXJJbmRleCkgPT4ge1xuICAgIGlmIChsYXllci5pc0NvbXBvc2l0ZSkge1xuICAgICAgY29tcG9zaXRlQ291bnQrKztcbiAgICB9IGVsc2UgaWYgKGxheWVyLnByb3BzLnZpc2libGUpIHtcblxuICAgICAgbGF5ZXIuZHJhd0xheWVyKHtcbiAgICAgICAgbW9kdWxlUGFyYW1ldGVyczogT2JqZWN0LmFzc2lnbih7fSwgbGF5ZXIucHJvcHMsIHtcbiAgICAgICAgICB2aWV3cG9ydDogbGF5ZXIuY29udGV4dC52aWV3cG9ydFxuICAgICAgICB9KSxcbiAgICAgICAgdW5pZm9ybXM6IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge3JlbmRlclBpY2tpbmdCdWZmZXI6IDAsIHBpY2tpbmdFbmFibGVkOiAwfSxcbiAgICAgICAgICBsYXllci5jb250ZXh0LnVuaWZvcm1zLFxuICAgICAgICAgIHtsYXllckluZGV4fVxuICAgICAgICApLFxuICAgICAgICBwYXJhbWV0ZXJzOiBsYXllci5wcm9wcy5wYXJhbWV0ZXJzIHx8IHt9XG4gICAgICB9KTtcbiAgICAgIHZpc2libGVDb3VudCsrO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHRvdGFsQ291bnQgPSBsYXllcnMubGVuZ3RoO1xuICBjb25zdCBwcmltaXRpdmVDb3VudCA9IHRvdGFsQ291bnQgLSBjb21wb3NpdGVDb3VudDtcbiAgY29uc3QgaGlkZGVuQ291bnQgPSBwcmltaXRpdmVDb3VudCAtIHZpc2libGVDb3VudDtcblxuICBjb25zdCBtZXNzYWdlID0gYFxcXG4jJHtyZW5kZXJDb3VudCsrfTogUmVuZGVyaW5nICR7dmlzaWJsZUNvdW50fSBvZiAke3RvdGFsQ291bnR9IGxheWVycyAke3Bhc3N9IFxcXG4oJHtoaWRkZW5Db3VudH0gaGlkZGVuLCAke2NvbXBvc2l0ZUNvdW50fSBjb21wb3NpdGUpYDtcblxuICBsb2cubG9nKDIsIG1lc3NhZ2UpO1xufVxuXG4vLyBQaWNrIGFsbCBvYmplY3RzIHdpdGhpbiB0aGUgZ2l2ZW4gYm91bmRpbmcgYm94XG5leHBvcnQgZnVuY3Rpb24gcXVlcnlMYXllcnMoZ2wsIHtcbiAgbGF5ZXJzLFxuICBwaWNraW5nRkJPLFxuICB4LFxuICB5LFxuICB3aWR0aCxcbiAgaGVpZ2h0LFxuICB2aWV3cG9ydCxcbiAgbW9kZVxufSkge1xuXG4gIC8vIENvbnZlcnQgZnJvbSBjYW52YXMgdG9wLWxlZnQgdG8gV2ViR0wgYm90dG9tLWxlZnQgY29vcmRpbmF0ZXNcbiAgLy8gQW5kIGNvbXBlbnNhdGUgZm9yIHBpeGVsUmF0aW9cbiAgY29uc3QgcGl4ZWxSYXRpbyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gOiAxO1xuICBjb25zdCBkZXZpY2VMZWZ0ID0gTWF0aC5yb3VuZCh4ICogcGl4ZWxSYXRpbyk7XG4gIGNvbnN0IGRldmljZUJvdHRvbSA9IE1hdGgucm91bmQoZ2wuY2FudmFzLmhlaWdodCAtIHkgKiBwaXhlbFJhdGlvKTtcbiAgY29uc3QgZGV2aWNlUmlnaHQgPSBNYXRoLnJvdW5kKCh4ICsgd2lkdGgpICogcGl4ZWxSYXRpbyk7XG4gIGNvbnN0IGRldmljZVRvcCA9IE1hdGgucm91bmQoZ2wuY2FudmFzLmhlaWdodCAtICh5ICsgaGVpZ2h0KSAqIHBpeGVsUmF0aW8pO1xuXG4gIGNvbnN0IHBpY2tJbmZvcyA9IGdldFVuaXF1ZXNGcm9tUGlja2luZ0J1ZmZlcihnbCwge1xuICAgIGxheWVycyxcbiAgICBwaWNraW5nRkJPLFxuICAgIGRldmljZVJlY3Q6IHtcbiAgICAgIHg6IGRldmljZUxlZnQsXG4gICAgICB5OiBkZXZpY2VUb3AsXG4gICAgICB3aWR0aDogZGV2aWNlUmlnaHQgLSBkZXZpY2VMZWZ0LFxuICAgICAgaGVpZ2h0OiBkZXZpY2VCb3R0b20gLSBkZXZpY2VUb3BcbiAgICB9XG4gIH0pO1xuXG4gIC8vIE9ubHkgcmV0dXJuIHVuaXF1ZSBpbmZvcywgaWRlbnRpZmllZCBieSBpbmZvLm9iamVjdFxuICBjb25zdCB1bmlxdWVJbmZvcyA9IG5ldyBNYXAoKTtcblxuICBwaWNrSW5mb3MuZm9yRWFjaChwaWNrSW5mbyA9PiB7XG4gICAgbGV0IGluZm8gPSBjcmVhdGVJbmZvKFtwaWNrSW5mby54IC8gcGl4ZWxSYXRpbywgcGlja0luZm8ueSAvIHBpeGVsUmF0aW9dLCB2aWV3cG9ydCk7XG4gICAgaW5mby5kZXZpY2VQaXhlbCA9IFtwaWNrSW5mby54LCBwaWNrSW5mby55XTtcbiAgICBpbmZvLnBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuICAgIGluZm8uY29sb3IgPSBwaWNrSW5mby5waWNrZWRDb2xvcjtcbiAgICBpbmZvLmluZGV4ID0gcGlja0luZm8ucGlja2VkT2JqZWN0SW5kZXg7XG4gICAgaW5mby5waWNrZWQgPSB0cnVlO1xuXG4gICAgaW5mbyA9IGdldExheWVyUGlja2luZ0luZm8oe2xheWVyOiBwaWNrSW5mby5waWNrZWRMYXllciwgaW5mbywgbW9kZX0pO1xuICAgIGlmICghdW5pcXVlSW5mb3MuaGFzKGluZm8ub2JqZWN0KSkge1xuICAgICAgdW5pcXVlSW5mb3Muc2V0KGluZm8ub2JqZWN0LCBpbmZvKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBBcnJheS5mcm9tKHVuaXF1ZUluZm9zLnZhbHVlcygpKTtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWRlcHRoLCBtYXgtc3RhdGVtZW50cyAqL1xuLy8gUGljayB0aGUgY2xvc2VzdCBvYmplY3QgYXQgdGhlIGdpdmVuICh4LHkpIGNvb3JkaW5hdGVcbmV4cG9ydCBmdW5jdGlvbiBwaWNrTGF5ZXJzKGdsLCB7XG4gIGxheWVycyxcbiAgcGlja2luZ0ZCTyxcbiAgeCxcbiAgeSxcbiAgcmFkaXVzLFxuICB2aWV3cG9ydCxcbiAgbW9kZSxcbiAgbGFzdFBpY2tlZEluZm9cbn0pIHtcblxuICAvLyBDb252ZXJ0IGZyb20gY2FudmFzIHRvcC1sZWZ0IHRvIFdlYkdMIGJvdHRvbS1sZWZ0IGNvb3JkaW5hdGVzXG4gIC8vIEFuZCBjb21wZW5zYXRlIGZvciBwaXhlbFJhdGlvXG4gIGNvbnN0IHBpeGVsUmF0aW8gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDogMTtcbiAgY29uc3QgZGV2aWNlWCA9IE1hdGgucm91bmQoeCAqIHBpeGVsUmF0aW8pO1xuICBjb25zdCBkZXZpY2VZID0gTWF0aC5yb3VuZChnbC5jYW52YXMuaGVpZ2h0IC0geSAqIHBpeGVsUmF0aW8pO1xuICBjb25zdCBkZXZpY2VSYWRpdXMgPSBNYXRoLnJvdW5kKHJhZGl1cyAqIHBpeGVsUmF0aW8pO1xuXG4gIGNvbnN0IHtcbiAgICBwaWNrZWRDb2xvcixcbiAgICBwaWNrZWRMYXllcixcbiAgICBwaWNrZWRPYmplY3RJbmRleFxuICB9ID0gZ2V0Q2xvc2VzdEZyb21QaWNraW5nQnVmZmVyKGdsLCB7XG4gICAgbGF5ZXJzLFxuICAgIHBpY2tpbmdGQk8sXG4gICAgZGV2aWNlWCxcbiAgICBkZXZpY2VZLFxuICAgIGRldmljZVJhZGl1c1xuICB9KTtcbiAgY29uc3QgYWZmZWN0ZWRMYXllcnMgPSBwaWNrZWRMYXllciA/IFtwaWNrZWRMYXllcl0gOiBbXTtcblxuICBpZiAobW9kZSA9PT0gJ2hvdmVyJykge1xuICAgIC8vIG9ubHkgaW52b2tlIG9uSG92ZXIgZXZlbnRzIGlmIHBpY2tlZCBvYmplY3QgaGFzIGNoYW5nZWRcbiAgICBjb25zdCBsYXN0UGlja2VkT2JqZWN0SW5kZXggPSBsYXN0UGlja2VkSW5mby5pbmRleDtcbiAgICBjb25zdCBsYXN0UGlja2VkTGF5ZXJJZCA9IGxhc3RQaWNrZWRJbmZvLmxheWVySWQ7XG4gICAgY29uc3QgcGlja2VkTGF5ZXJJZCA9IHBpY2tlZExheWVyICYmIHBpY2tlZExheWVyLnByb3BzLmlkO1xuXG4gICAgLy8gcHJvY2VlZCBvbmx5IGlmIHBpY2tlZCBvYmplY3QgY2hhbmdlZFxuICAgIGlmIChwaWNrZWRMYXllcklkICE9PSBsYXN0UGlja2VkTGF5ZXJJZCB8fCBwaWNrZWRPYmplY3RJbmRleCAhPT0gbGFzdFBpY2tlZE9iamVjdEluZGV4KSB7XG4gICAgICBpZiAocGlja2VkTGF5ZXJJZCAhPT0gbGFzdFBpY2tlZExheWVySWQpIHtcbiAgICAgICAgLy8gV2UgY2Fubm90IHN0b3JlIGEgcmVmIHRvIGxhc3RQaWNrZWRMYXllciBpbiB0aGUgY29udGV4dCBiZWNhdXNlXG4gICAgICAgIC8vIHRoZSBzdGF0ZSBvZiBhbiBvdXRkYXRlZCBsYXllciBpcyBubyBsb25nZXIgdmFsaWRcbiAgICAgICAgLy8gYW5kIHRoZSBwcm9wcyBtYXkgaGF2ZSBjaGFuZ2VkXG4gICAgICAgIGNvbnN0IGxhc3RQaWNrZWRMYXllciA9IGxheWVycy5maW5kKGxheWVyID0+IGxheWVyLnByb3BzLmlkID09PSBsYXN0UGlja2VkTGF5ZXJJZCk7XG4gICAgICAgIGlmIChsYXN0UGlja2VkTGF5ZXIpIHtcbiAgICAgICAgICAvLyBMZXQgbGVhdmUgZXZlbnQgZmlyZSBiZWZvcmUgZW50ZXIgZXZlbnRcbiAgICAgICAgICBhZmZlY3RlZExheWVycy51bnNoaWZ0KGxhc3RQaWNrZWRMYXllcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIGxheWVyIG1hbmFnZXIgY29udGV4dFxuICAgICAgbGFzdFBpY2tlZEluZm8ubGF5ZXJJZCA9IHBpY2tlZExheWVySWQ7XG4gICAgICBsYXN0UGlja2VkSW5mby5pbmRleCA9IHBpY2tlZE9iamVjdEluZGV4O1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGJhc2VJbmZvID0gY3JlYXRlSW5mbyhbeCwgeV0sIHZpZXdwb3J0KTtcbiAgYmFzZUluZm8uZGV2aWNlUGl4ZWwgPSBbZGV2aWNlWCwgZGV2aWNlWV07XG4gIGJhc2VJbmZvLnBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuXG4gIC8vIFVzZSBhIE1hcCB0byBzdG9yZSBhbGwgcGlja2luZyBpbmZvcy5cbiAgLy8gVGhlIGZvbGxvd2luZyB0d28gZm9yRWFjaCBsb29wcyBhcmUgdGhlIHJlc3VsdCBvZlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdWJlci9kZWNrLmdsL2lzc3Vlcy80NDNcbiAgLy8gUGxlYXNlIGJlIHZlcnkgY2FyZWZ1bCB3aGVuIGNoYW5naW5nIHRoaXMgcGF0dGVyblxuICBjb25zdCBpbmZvcyA9IG5ldyBNYXAoKTtcbiAgY29uc3QgdW5oYW5kbGVkUGlja0luZm9zID0gW107XG5cbiAgYWZmZWN0ZWRMYXllcnMuZm9yRWFjaChsYXllciA9PiB7XG4gICAgbGV0IGluZm8gPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlSW5mbyk7XG5cbiAgICBpZiAobGF5ZXIgPT09IHBpY2tlZExheWVyKSB7XG4gICAgICBpbmZvLmNvbG9yID0gcGlja2VkQ29sb3I7XG4gICAgICBpbmZvLmluZGV4ID0gcGlja2VkT2JqZWN0SW5kZXg7XG4gICAgICBpbmZvLnBpY2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaW5mbyA9IGdldExheWVyUGlja2luZ0luZm8oe2xheWVyLCBpbmZvLCBtb2RlfSk7XG5cbiAgICAvLyBUaGlzIGd1YXJhbnRlZXMgdGhhdCB0aGVyZSB3aWxsIGJlIG9ubHkgb25lIGNvcHkgb2YgaW5mbyBmb3JcbiAgICAvLyBvbmUgY29tcG9zaXRlIGxheWVyXG4gICAgaWYgKGluZm8pIHtcbiAgICAgIGluZm9zLnNldChpbmZvLmxheWVyLmlkLCBpbmZvKTtcbiAgICB9XG4gIH0pO1xuXG4gIGluZm9zLmZvckVhY2goaW5mbyA9PiB7XG4gICAgbGV0IGhhbmRsZWQgPSBmYWxzZTtcbiAgICAvLyBQZXItbGF5ZXIgZXZlbnQgaGFuZGxlcnMgKGUuZy4gb25DbGljaywgb25Ib3ZlcikgYXJlIHByb3ZpZGVkIGJ5IHRoZVxuICAgIC8vIHVzZXIgYW5kIG91dCBvZiBkZWNrLmdsJ3MgY29udHJvbC4gSXQncyB2ZXJ5IG11Y2ggcG9zc2libGUgdGhhdFxuICAgIC8vIHRoZSB1c2VyIGNhbGxzIFJlYWN0IGxpZmVjeWNsZSBtZXRob2RzIGluIHRoZXNlIGZ1bmN0aW9uLCBzdWNoIGFzXG4gICAgLy8gUmVhY3RDb21wb25lbnQuc2V0U3RhdGUoKS4gUmVhY3QgbGlmZWN5Y2xlIG1ldGhvZHMgc29tZXRpbWVzIGluZHVjZVxuICAgIC8vIGEgcmUtcmVuZGVyIGFuZCByZS1nZW5lcmF0aW9uIG9mIHByb3BzIG9mIGRlY2suZ2wgYW5kIGl0cyBsYXllcnMsXG4gICAgLy8gd2hpY2ggaW52YWxpZGF0ZXMgYWxsIGxheWVycyBjdXJyZW50bHkgcGFzc2VkIHRvIHRoaXMgdmVyeSBmdW5jdGlvbi5cblxuICAgIC8vIFRoZXJlZm9yZSwgcGVyLWxheWVyIGV2ZW50IGhhbmRsZXJzIG11c3QgYmUgaW52b2tlZCBhdCB0aGUgZW5kXG4gICAgLy8gb2YgdGhpcyBmdW5jdGlvbi4gTk8gb3BlcmF0aW9uIHRoYXQgcmVsaWVzIG9uIHRoZSBzdGF0ZXMgb2YgY3VycmVudFxuICAgIC8vIGxheWVycyBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIHRoaXMgY29kZS5cbiAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICBjYXNlICdjbGljayc6IGhhbmRsZWQgPSBpbmZvLmxheWVyLnByb3BzLm9uQ2xpY2soaW5mbyk7IGJyZWFrO1xuICAgIGNhc2UgJ2hvdmVyJzogaGFuZGxlZCA9IGluZm8ubGF5ZXIucHJvcHMub25Ib3ZlcihpbmZvKTsgYnJlYWs7XG4gICAgY2FzZSAncXVlcnknOiBicmVhaztcbiAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gcGljayB0eXBlJyk7XG4gICAgfVxuXG4gICAgaWYgKCFoYW5kbGVkKSB7XG4gICAgICB1bmhhbmRsZWRQaWNrSW5mb3MucHVzaChpbmZvKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB1bmhhbmRsZWRQaWNrSW5mb3M7XG59XG5cbi8qKlxuICogUGljayBhdCBhIHNwZWNpZmllZCBwaXhlbCB3aXRoIGEgdG9sZXJhbmNlIHJhZGl1c1xuICogUmV0dXJucyB0aGUgY2xvc2VzdCBvYmplY3QgdG8gdGhlIHBpeGVsIGluIHNoYXBlIGB7cGlja2VkQ29sb3IsIHBpY2tlZExheWVyLCBwaWNrZWRPYmplY3RJbmRleH1gXG4gKi9cbmZ1bmN0aW9uIGdldENsb3Nlc3RGcm9tUGlja2luZ0J1ZmZlcihnbCwge1xuICBsYXllcnMsXG4gIHBpY2tpbmdGQk8sXG4gIGRldmljZVgsXG4gIGRldmljZVksXG4gIGRldmljZVJhZGl1c1xufSkge1xuICAvLyBDcmVhdGUgYSBib3ggb2Ygc2l6ZSBgcmFkaXVzICogMiArIDFgIGNlbnRlcmVkIGF0IFtkZXZpY2VYLCBkZXZpY2VZXVxuICBjb25zdCB4ID0gTWF0aC5tYXgoMCwgZGV2aWNlWCAtIGRldmljZVJhZGl1cyk7XG4gIGNvbnN0IHkgPSBNYXRoLm1heCgwLCBkZXZpY2VZIC0gZGV2aWNlUmFkaXVzKTtcbiAgY29uc3Qgd2lkdGggPSBNYXRoLm1pbihwaWNraW5nRkJPLndpZHRoLCBkZXZpY2VYICsgZGV2aWNlUmFkaXVzKSAtIHggKyAxO1xuICBjb25zdCBoZWlnaHQgPSBNYXRoLm1pbihwaWNraW5nRkJPLmhlaWdodCwgZGV2aWNlWSArIGRldmljZVJhZGl1cykgLSB5ICsgMTtcblxuICBjb25zdCBwaWNrZWRDb2xvcnMgPSBnZXRQaWNrZWRDb2xvcnMoZ2wsIHtsYXllcnMsIHBpY2tpbmdGQk8sIGRldmljZVJlY3Q6IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fX0pO1xuXG4gIC8vIFRyYXZlcnNlIGFsbCBwaXhlbHMgaW4gcGlja2luZyByZXN1bHRzIGFuZCBmaW5kIHRoZSBvbmUgY2xvc2VzdCB0byB0aGUgc3VwcGxpZWRcbiAgLy8gW2RldmljZVgsIGRldmljZVldXG4gIGxldCBtaW5TcXVhcmVEaXN0YW5jZVRvQ2VudGVyID0gZGV2aWNlUmFkaXVzICogZGV2aWNlUmFkaXVzO1xuICBsZXQgY2xvc2VzdFJlc3VsdFRvQ2VudGVyID0ge1xuICAgIHBpY2tlZENvbG9yOiBFTVBUWV9QSVhFTCxcbiAgICBwaWNrZWRMYXllcjogbnVsbCxcbiAgICBwaWNrZWRPYmplY3RJbmRleDogLTFcbiAgfTtcbiAgbGV0IGkgPSAwO1xuXG4gIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IGhlaWdodDsgcm93KyspIHtcbiAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCB3aWR0aDsgY29sKyspIHtcbiAgICAgIC8vIERlY29kZSBwaWNrZWQgbGF5ZXIgZnJvbSBjb2xvclxuICAgICAgY29uc3QgcGlja2VkTGF5ZXJJbmRleCA9IHBpY2tlZENvbG9yc1tpICsgM10gLSAxO1xuXG4gICAgICBpZiAocGlja2VkTGF5ZXJJbmRleCA+PSAwKSB7XG4gICAgICAgIGNvbnN0IGR4ID0gY29sICsgeCAtIGRldmljZVg7XG4gICAgICAgIGNvbnN0IGR5ID0gcm93ICsgeSAtIGRldmljZVk7XG4gICAgICAgIGNvbnN0IGQyID0gZHggKiBkeCArIGR5ICogZHk7XG5cbiAgICAgICAgaWYgKGQyIDw9IG1pblNxdWFyZURpc3RhbmNlVG9DZW50ZXIpIHtcbiAgICAgICAgICBtaW5TcXVhcmVEaXN0YW5jZVRvQ2VudGVyID0gZDI7XG5cbiAgICAgICAgICAvLyBEZWNvZGUgcGlja2VkIG9iamVjdCBpbmRleCBmcm9tIGNvbG9yXG4gICAgICAgICAgY29uc3QgcGlja2VkQ29sb3IgPSBwaWNrZWRDb2xvcnMuc2xpY2UoaSwgaSArIDQpO1xuICAgICAgICAgIGNvbnN0IHBpY2tlZExheWVyID0gbGF5ZXJzW3BpY2tlZExheWVySW5kZXhdO1xuICAgICAgICAgIGNvbnN0IHBpY2tlZE9iamVjdEluZGV4ID0gcGlja2VkTGF5ZXIuZGVjb2RlUGlja2luZ0NvbG9yKHBpY2tlZENvbG9yKTtcbiAgICAgICAgICBjbG9zZXN0UmVzdWx0VG9DZW50ZXIgPSB7cGlja2VkQ29sb3IsIHBpY2tlZExheWVyLCBwaWNrZWRPYmplY3RJbmRleH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGkgKz0gNDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2xvc2VzdFJlc3VsdFRvQ2VudGVyO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtZGVwdGgsIG1heC1zdGF0ZW1lbnRzICovXG5cbi8qKlxuICogUXVlcnkgd2l0aGluIGEgc3BlY2lmaWVkIHJlY3RhbmdsZVxuICogUmV0dXJucyBhcnJheSBvZiB1bmlxdWUgb2JqZWN0cyBpbiBzaGFwZSBge3gsIHksIHBpY2tlZENvbG9yLCBwaWNrZWRMYXllciwgcGlja2VkT2JqZWN0SW5kZXh9YFxuICovXG5mdW5jdGlvbiBnZXRVbmlxdWVzRnJvbVBpY2tpbmdCdWZmZXIoZ2wsIHtcbiAgbGF5ZXJzLFxuICBwaWNraW5nRkJPLFxuICBkZXZpY2VSZWN0OiB7eCwgeSwgd2lkdGgsIGhlaWdodH1cbn0pIHtcbiAgY29uc3QgcGlja2VkQ29sb3JzID0gZ2V0UGlja2VkQ29sb3JzKGdsLCB7bGF5ZXJzLCBwaWNraW5nRkJPLCBkZXZpY2VSZWN0OiB7eCwgeSwgd2lkdGgsIGhlaWdodH19KTtcbiAgY29uc3QgdW5pcXVlQ29sb3JzID0gbmV3IE1hcCgpO1xuXG4gIC8vIFRyYXZlcnNlIGFsbCBwaXhlbHMgaW4gcGlja2luZyByZXN1bHRzIGFuZCBnZXQgdW5pcXVlIGNvbG9yc1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBpY2tlZENvbG9ycy5sZW5ndGg7IGkgKz0gNCkge1xuICAgIC8vIERlY29kZSBwaWNrZWQgbGF5ZXIgZnJvbSBjb2xvclxuICAgIGNvbnN0IHBpY2tlZExheWVySW5kZXggPSBwaWNrZWRDb2xvcnNbaSArIDNdIC0gMTtcblxuICAgIGlmIChwaWNrZWRMYXllckluZGV4ID49IDApIHtcbiAgICAgIGNvbnN0IHBpY2tlZENvbG9yID0gcGlja2VkQ29sb3JzLnNsaWNlKGksIGkgKyA0KTtcbiAgICAgIGNvbnN0IGNvbG9yS2V5ID0gcGlja2VkQ29sb3Iuam9pbignLCcpO1xuICAgICAgaWYgKCF1bmlxdWVDb2xvcnMuaGFzKGNvbG9yS2V5KSkge1xuICAgICAgICBjb25zdCBwaWNrZWRMYXllciA9IGxheWVyc1twaWNrZWRMYXllckluZGV4XTtcbiAgICAgICAgdW5pcXVlQ29sb3JzLnNldChjb2xvcktleSwge1xuICAgICAgICAgIHBpY2tlZENvbG9yLFxuICAgICAgICAgIHBpY2tlZExheWVyLFxuICAgICAgICAgIHBpY2tlZE9iamVjdEluZGV4OiBwaWNrZWRMYXllci5kZWNvZGVQaWNraW5nQ29sb3IocGlja2VkQ29sb3IpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBBcnJheS5mcm9tKHVuaXF1ZUNvbG9ycy52YWx1ZXMoKSk7XG59XG5cbi8vIFJldHVybnMgYW4gVWludDhDbGFtcGVkQXJyYXkgb2YgcGlja2VkIHBpeGVsc1xuZnVuY3Rpb24gZ2V0UGlja2VkQ29sb3JzKGdsLCB7XG4gIGxheWVycyxcbiAgcGlja2luZ0ZCTyxcbiAgZGV2aWNlUmVjdDoge3gsIHksIHdpZHRoLCBoZWlnaHR9XG59KSB7XG4gIC8vIE1ha2Ugc3VyZSB3ZSBjbGVhciBzY2lzc29yIHRlc3QgYW5kIGZibyBiaW5kaW5ncyBpbiBjYXNlIG9mIGV4Y2VwdGlvbnNcbiAgLy8gV2UgYXJlIG9ubHkgaW50ZXJlc3RlZCBpbiBvbmUgcGl4ZWwsIG5vIG5lZWQgdG8gcmVuZGVyIGFueXRoaW5nIGVsc2VcbiAgLy8gTm90ZSB0aGF0IHRoZSBjYWxsYmFjayBoZXJlIGlzIGNhbGxlZCBzeW5jaHJvbm91c2x5LlxuICAvLyBTZXQgYmxlbmQgbW9kZSBmb3IgcGlja2luZ1xuICAvLyBhbHdheXMgb3ZlcndyaXRlIGV4aXN0aW5nIHBpeGVsIHdpdGggW3IsZyxiLGxheWVySW5kZXhdXG4gIHJldHVybiB3aXRoUGFyYW1ldGVycyhnbCwge1xuICAgIGZyYW1lYnVmZmVyOiBwaWNraW5nRkJPLFxuICAgIHNjaXNzb3JUZXN0OiB0cnVlLFxuICAgIHNjaXNzb3I6IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSxcbiAgICBibGVuZDogdHJ1ZSxcbiAgICBibGVuZEZ1bmM6IFtnbC5PTkUsIGdsLlpFUk8sIGdsLkNPTlNUQU5UX0FMUEhBLCBnbC5aRVJPXSxcbiAgICBibGVuZEVxdWF0aW9uOiBnbC5GVU5DX0FERFxuICAgIC8vIFRPRE8gLSBTZXQgY2xlYXIgY29sb3JcbiAgfSwgKCkgPT4ge1xuXG4gICAgLy8gQ2xlYXIgdGhlIGZyYW1lIGJ1ZmZlclxuICAgIGdsLmNsZWFyKEdMLkNPTE9SX0JVRkZFUl9CSVQgfCBHTC5ERVBUSF9CVUZGRVJfQklUKTtcblxuICAgIC8vIFJlbmRlciBhbGwgcGlja2FibGUgbGF5ZXJzIGluIHBpY2tpbmcgY29sb3JzXG4gICAgbGF5ZXJzLmZvckVhY2goKGxheWVyLCBsYXllckluZGV4KSA9PiB7XG4gICAgICBpZiAoIWxheWVyLmlzQ29tcG9zaXRlICYmIGxheWVyLnByb3BzLnZpc2libGUgJiYgbGF5ZXIucHJvcHMucGlja2FibGUpIHtcblxuICAgICAgICAvLyBFbmNvZGUgbGF5ZXJJbmRleCB3aXRoIGFscGhhXG4gICAgICAgIHNldFBhcmFtZXRlcnMoZ2wsIHtibGVuZENvbG9yOiBbMCwgMCwgMCwgKGxheWVySW5kZXggKyAxKSAvIDI1NV19KTtcbiAgICAgICAgbGF5ZXIuZHJhd0xheWVyKHtcbiAgICAgICAgICBtb2R1bGVQYXJhbWV0ZXJzOiBPYmplY3QuYXNzaWduKHt9LCBsYXllci5wcm9wcywge1xuICAgICAgICAgICAgdmlld3BvcnQ6IGxheWVyLmNvbnRleHQudmlld3BvcnRcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB1bmlmb3JtczogT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIHtyZW5kZXJQaWNraW5nQnVmZmVyOiAxLCBwaWNraW5nRW5hYmxlZDogMX0sXG4gICAgICAgICAgICBsYXllci5jb250ZXh0LnVuaWZvcm1zLFxuICAgICAgICAgICAge2xheWVySW5kZXh9XG4gICAgICAgICAgKSxcbiAgICAgICAgICBwYXJhbWV0ZXJzOiBsYXllci5wcm9wcy5wYXJhbWV0ZXJzIHx8IHt9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gUmVhZCBjb2xvciBpbiB0aGUgY2VudHJhbCBwaXhlbCwgdG8gYmUgbWFwcGVkIHdpdGggcGlja2luZyBjb2xvcnNcbiAgICBjb25zdCBwaWNrZWRDb2xvcnMgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgIGdsLnJlYWRQaXhlbHMoeCwgeSwgd2lkdGgsIGhlaWdodCwgR0wuUkdCQSwgR0wuVU5TSUdORURfQllURSwgcGlja2VkQ29sb3JzKTtcblxuICAgIHJldHVybiBwaWNrZWRDb2xvcnM7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJbmZvKHBpeGVsLCB2aWV3cG9ydCkge1xuICAvLyBBc3NpZ24gYSBudW1iZXIgb2YgcG90ZW50aWFsbHkgdXNlZnVsIHByb3BzIHRvIHRoZSBcImluZm9cIiBvYmplY3RcbiAgcmV0dXJuIHtcbiAgICBjb2xvcjogRU1QVFlfUElYRUwsXG4gICAgbGF5ZXI6IG51bGwsXG4gICAgaW5kZXg6IC0xLFxuICAgIHBpY2tlZDogZmFsc2UsXG4gICAgeDogcGl4ZWxbMF0sXG4gICAgeTogcGl4ZWxbMV0sXG4gICAgcGl4ZWwsXG4gICAgbG5nTGF0OiB2aWV3cG9ydC51bnByb2plY3QocGl4ZWwpXG4gIH07XG59XG5cbi8vIFdhbGsgdXAgdGhlIGxheWVyIGNvbXBvc2l0ZSBjaGFpbiB0byBwb3B1bGF0ZSB0aGUgaW5mbyBvYmplY3RcbmZ1bmN0aW9uIGdldExheWVyUGlja2luZ0luZm8oe2xheWVyLCBpbmZvLCBtb2RlfSkge1xuICB3aGlsZSAobGF5ZXIgJiYgaW5mbykge1xuICAgIC8vIEZvciBhIGNvbXBvc2l0ZSBsYXllciwgc291cmNlTGF5ZXIgd2lsbCBwb2ludCB0byB0aGUgc3VibGF5ZXJcbiAgICAvLyB3aGVyZSB0aGUgZXZlbnQgb3JpZ2luYXRlcyBmcm9tLlxuICAgIC8vIEl0IHByb3ZpZGVzIGFkZGl0aW9uYWwgY29udGV4dCBmb3IgdGhlIGNvbXBvc2l0ZSBsYXllcidzXG4gICAgLy8gZ2V0UGlja2luZ0luZm8oKSBtZXRob2QgdG8gcG9wdWxhdGUgdGhlIGluZm8gb2JqZWN0XG4gICAgY29uc3Qgc291cmNlTGF5ZXIgPSBpbmZvLmxheWVyIHx8IGxheWVyO1xuICAgIGluZm8ubGF5ZXIgPSBsYXllcjtcbiAgICAvLyBsYXllci5waWNrTGF5ZXIoKSBmdW5jdGlvbiByZXF1aXJlcyBhIG5vbi1udWxsIGBgYGxheWVyLnN0YXRlYGBgXG4gICAgLy8gb2JqZWN0IHRvIGZ1bnRpb24gcHJvcGVybHkuIFNvIHRoZSBsYXllciByZWZlcmVjZWQgaGVyZVxuICAgIC8vIG11c3QgYmUgdGhlIFwiY3VycmVudFwiIGxheWVyLCBub3QgYW4gXCJvdXQtZGF0ZWRcIiAvIFwiaW52YWxpZGF0ZWRcIiBsYXllclxuICAgIGluZm8gPSBsYXllci5waWNrTGF5ZXIoe2luZm8sIG1vZGUsIHNvdXJjZUxheWVyfSk7XG4gICAgbGF5ZXIgPSBsYXllci5wYXJlbnRMYXllcjtcbiAgfVxuICByZXR1cm4gaW5mbztcbn1cbiJdfQ==